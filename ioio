// App.js - Componente principale con funzionalità di pagamento e ricerca integrata
import React, { useState, useEffect } from 'react';
import './App.css';
import ConversationBox from './components/ConversationBox';
import BookingHistory from './components/BookingHistory';
import LoadingIndicator from './components/LoadingIndicator';
import SearchBox from './components/SearchBox';
import PaymentModal from './components/PaymentModal';
import ApiService from './services/ApiService';
import BookingService from './services/BookingService';
import PaymentService from './services/PaymentService';
import { Elements } from '@stripe/react-stripe-js';
import { loadStripe } from '@stripe/stripe-js';

// Caricamento dell'istanza Stripe (mettere la chiave pubblica nella variabile d'ambiente)
const stripePromise = loadStripe(process.env.REACT_APP_STRIPE_PUBLIC_KEY);

function App() {
  const [conversations, setConversations] = useState([]);
  const [loading, setLoading] = useState(false);
  const [bookingHistory, setBookingHistory] = useState([]);
  const [user, setUser] = useState(null);
  const [searchResults, setSearchResults] = useState([]);
  const [isSearching, setIsSearching] = useState(false);
  const [activeBooking, setActiveBooking] = useState(null);
  const [showPaymentModal, setShowPaymentModal] = useState(false);
  
  useEffect(() => {
    // Controlla se l'utente è autenticato
    const checkAuth = async () => {
      const userData = localStorage.getItem('user');
      if (userData) {
        setUser(JSON.parse(userData));
        // Carica lo storico delle prenotazioni
        loadBookingHistory(JSON.parse(userData).id);
      }
    };
    
    checkAuth();
  }, []);

  const loadBookingHistory = async (userId) => {
    try {
      const history = await BookingService.getUserBookings(userId);
      setBookingHistory(history);
    } catch (error) {
      console.error('Errore nel caricamento dello storico prenotazioni:', error);
    }
  };

  const handleSearch = async (query, type) => {
    setIsSearching(true);
    try {
      const results = await ApiService.searchOptions(query, type);
      setSearchResults(results);
    } catch (error) {
      console.error('Errore nella ricerca:', error);
    } finally {
      setIsSearching(false);
    }
  };

  const handleSearchOptionSelect = (option) => {
    // Aggiungi l'opzione selezionata alla conversazione
    const selectionMessage = { 
      sender: 'user', 
      text: `Ho scelto: ${option.name || option.title}`, 
      timestamp: new Date() 
    };
    setConversations(prev => [...prev, selectionMessage]);
    
    // Rispondi con dettagli sull'opzione selezionata
    const responseMessage = { 
      sender: 'ai', 
      text: `Ottima scelta! Hai selezionato ${option.name || option.title}. Desideri procedere con la prenotazione?`, 
      timestamp: new Date() 
    };
    setConversations(prev => [...prev, responseMessage]);
    
    // Memorizza l'opzione per la prenotazione
    setActiveBooking({
      type: option.type,
      details: option
    });
    
    // Nascondi i risultati della ricerca
    setSearchResults([]);
  };

  const handleUserMessage = async (message) => {
    // Aggiungi il messaggio dell'utente alla conversazione
    const newUserMessage = { sender: 'user', text: message, timestamp: new Date() };
    setConversations(prev => [...prev, newUserMessage]);
    setLoading(true);

    try {
      // Se il messaggio contiene termini di ricerca, esegui una ricerca
      if (message.toLowerCase().includes('cerca') || message.toLowerCase().includes('trova')) {
        const searchTerms = extractSearchTerms(message);
        if (searchTerms) {
          // Esegui la ricerca
          const results = await ApiService.searchOptions(searchTerms.query, searchTerms.type);
          setSearchResults(results);
          
          // Aggiungi risposta dell'AI
          const searchResponseMessage = { 
            sender: 'ai', 
            text: `Ecco i risultati per la tua ricerca di ${searchTerms.type}:`, 
            timestamp: new Date() 
          };
          setConversations(prev => [...prev, searchResponseMessage]);
          setLoading(false);
          return;
        }
      }
      
      // Se abbiamo una prenotazione attiva e il messaggio indica conferma
      if (activeBooking && (message.toLowerCase().includes('conferma') || message.toLowerCase().includes('procedi'))) {
        const confirmationMessage = { 
          sender: 'ai', 
          text: `Procediamo con la prenotazione di ${activeBooking.type}. Ti porterò alla pagina di pagamento.`, 
          timestamp: new Date() 
        };
        setConversations(prev => [...prev, confirmationMessage]);
        
        // Mostra il modale di pagamento
        setShowPaymentModal(true);
        setLoading(false);
        return;
      }
      
      // Comunica con l'API di GPT per analizzare la richiesta
      const response = await ApiService.processUserRequest(message, user?.id);
      
      // Analizza la risposta
      const { text, bookingDetails, searchSuggestion } = response;
      
      // Aggiungi la risposta alla conversazione
      const newAiMessage = { sender: 'ai', text, timestamp: new Date() };
      setConversations(prev => [...prev, newAiMessage]);
      
      // Se contiene suggerimento di ricerca, esegui la ricerca
      if (searchSuggestion) {
        const results = await ApiService.searchOptions(searchSuggestion.query, searchSuggestion.type);
        setSearchResults(results);
      }
      
      // Se contiene dettagli di prenotazione
      if (bookingDetails) {
        setActiveBooking({
          type: bookingDetails.type,
          details: bookingDetails.details
        });
        
        // Se la prenotazione richiede il pagamento immediato
        if (bookingDetails.requiresPayment) {
          // Mostra il modale di pagamento
          setShowPaymentModal(true);
        }
      }
    } catch (error) {
      console.error('Errore nella comunicazione con l\'API:', error);
      // Messaggio di errore
      const errorMessage = { 
        sender: 'system', 
        text: 'Mi dispiace, si è verificato un errore. Riprova più tardi.', 
        timestamp: new Date() 
      };
      setConversations(prev => [...prev, errorMessage]);
    } finally {
      setLoading(false);
    }
  };

  const handleLogin = (userData) => {
    setUser(userData);
    localStorage.setItem('user', JSON.stringify(userData));
    loadBookingHistory(userData.id);
  };

  const handleLogout = () => {
    setUser(null);
    localStorage.removeItem('user');
    setBookingHistory([]);
    setConversations([]);
    setActiveBooking(null);
  };

  const handlePaymentComplete = async (paymentResult) => {
    setShowPaymentModal(false);
    
    if (paymentResult.success) {
      try {
        // Finalizza la prenotazione con il pagamento
        const bookingResult = await BookingService.finalizeBooking(activeBooking, user.id, paymentResult.paymentId);
        
        // Aggiorna lo storico prenotazioni
        loadBookingHistory(user.id);
        
        // Messaggio di conferma
        const confirmationMessage = { 
          sender: 'system', 
          type: 'booking', 
          data: {
            ...activeBooking,
            confirmed: true,
            confirmationCode: bookingResult.confirmationCode,
            totalPrice: bookingResult.totalPrice,
            commission: 0.50
          },
          timestamp: new Date() 
        };
        setConversations(prev => [...prev, confirmationMessage]);
        
        // Reset della prenotazione attiva
        setActiveBooking(null);
      } catch (error) {
        console.error('Errore nella finalizzazione della prenotazione:', error);
        const errorMessage = { 
          sender: 'system', 
          text: 'Mi dispiace, si è verificato un errore durante la conferma della prenotazione. Il pagamento è stato elaborato ma contattaci per la conferma.', 
          timestamp: new Date() 
        };
        setConversations(prev => [...prev, errorMessage]);
      }
    } else {
      // Messaggio di errore pagamento
      const errorMessage = { 
        sender: 'system', 
        text: `Mi dispiace, il pagamento non è andato a buon fine: ${paymentResult.message}`, 
        timestamp: new Date() 
      };
      setConversations(prev => [...prev, errorMessage]);
    }
  };

  const extractSearchTerms = (message) => {
    // Estrai i termini di ricerca dal messaggio
    const hotelMatch = message.match(/cerca\s+hotel\s+(?:a|in|per)\s+([^\s,\.]+)/i);
    const restaurantMatch = message.match(/cerca\s+ristorante\s+(?:a|in|per)\s+([^\s,\.]+)/i);
    const flightMatch = message.match(/cerca\s+voli\s+(?:a|per|verso)\s+([^\s,\.]+)/i);
    
    if (hotelMatch) {
      return { type: 'hotel', query: hotelMatch[1] };
    } else if (restaurantMatch) {
      return { type: 'restaurant', query: restaurantMatch[1] };
    } else if (flightMatch) {
      return { type: 'flight', query: flightMatch[1] };
    }
    
    return null;
  };

  return (
    <div className="app-container">
      <header>
        <h1>Concierge AI</h1>
        <p>Il tuo assistente di prenotazione personale</p>
        {user ? (
          <div className="user-panel">
            <p>Ciao, {user.name}</p>
            <button onClick={handleLogout}>Logout</button>
          </div>
        ) : (
          <LoginRegister onLogin={handleLogin} />
        )}
      </header>
      
      <main>
        <ConversationBox 
          conversations={conversations} 
          onSendMessage={handleUserMessage} 
          loading={loading}
        />
        
        {searchResults.length > 0 && (
          <SearchBox 
            results={searchResults} 
            isLoading={isSearching}
            onSelectOption={handleSearchOptionSelect}
          />
        )}
        
        {user && (
          <BookingHistory bookings={bookingHistory} />
        )}
      </main>
      
      {showPaymentModal && (
        <Elements stripe={stripePromise}>
          <PaymentModal 
            booking={activeBooking}
            onClose={() => setShowPaymentModal(false)}
            onComplete={handlePaymentComplete}
            commission={0.50}
          />
        </Elements>
      )}
      
      <footer>
        <p>Concierge AI - Commissione fissa di 0,50€ per prenotazione</p>
      </footer>
    </div>
  );
}

export default App;

// SearchBox.js - Componente per mostrare i risultati della ricerca dinamica
import React from 'react';
import './SearchBox.css';

function SearchBox({ results, isLoading, onSelectOption }) {
  if (isLoading) {
    return (
      <div className="search-results-container">
        <div className="search-loading">
          <div className="spinner"></div>
          <p>Ricerca in corso...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="search-results-container">
      <h3>Risultati della ricerca</h3>
      <div className="search-results-list">
        {results.map((result, index) => (
          <div 
            key={index} 
            className="search-result-item"
            onClick={() => onSelectOption(result)}
          >
            <div className="result-image">
              {result.imageUrl ? (
                <img src={result.imageUrl} alt={result.name || result.title} />
              ) : (
                <div className="placeholder-image"></div>
              )}
            </div>
            <div className="result-details">
              <h4>{result.name || result.title}</h4>
              <p className="result-location">{result.location}</p>
              <p className="result-description">{result.description}</p>
              <div className="result-price">
                {result.price && (
                  <span className="price">{result.price}€</span>
                )}
                {result.rating && (
                  <span className="rating">
                    {Array(Math.round(result.rating)).fill('★').join('')}
                    {Array(5 - Math.round(result.rating)).fill('☆').join('')}
                  </span>
                )}
              </div>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}

export default SearchBox;

// PaymentModal.js - Componente per gestire i pagamenti tramite Stripe
import React, { useState } from 'react';
import { CardElement, useStripe, useElements } from '@stripe/react-stripe-js';
import './PaymentModal.css';
import PaymentService from '../services/PaymentService';

function PaymentModal({ booking, onClose, onComplete, commission }) {
  const stripe = useStripe();
  const elements = useElements();
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  
  // Calcola il prezzo totale
  const calculateTotal = () => {
    const basePrice = booking.details.price || 0;
    return (parseFloat(basePrice) + parseFloat(commission)).toFixed(2);
  };
  
  const handleSubmit = async (event) => {
    event.preventDefault();
    
    if (!stripe || !elements) {
      return;
    }
    
    setLoading(true);
    setError(null);
    
    try {
      // Crea intent di pagamento sul server
      const paymentIntent = await PaymentService.createPaymentIntent({
        amount: calculateTotal(),
        description: `${booking.type} - ${booking.details.name || booking.details.title}`,
        bookingType: booking.type
      });
      
      // Conferma il pagamento con Stripe
      const result = await stripe.confirmCardPayment(paymentIntent.clientSecret, {
        payment_method: {
          card: elements.getElement(CardElement),
          billing_details: {
            name: document.getElementById('name').value,
            email: document.getElementById('email').value,
          },
        }
      });
      
      if (result.error) {
        setError(result.error.message);
        onComplete({ success: false, message: result.error.message });
      } else {
        // Pagamento completato con successo
        onComplete({ 
          success: true, 
          paymentId: result.paymentIntent.id
        });
      }
    } catch (error) {
      setError('Si è verificato un errore durante l'elaborazione del pagamento');
      onComplete({ success: false, message: 'Errore del server' });
    } finally {
      setLoading(false);
    }
  };
  
  return (
    <div className="payment-modal-overlay">
      <div className="payment-modal">
        <div className="payment-modal-header">
          <h2>Completa il pagamento</h2>
          <button className="close-button" onClick={onClose}>&times;</button>
        </div>
        
        <div className="booking-summary">
          <h3>Riepilogo prenotazione</h3>
          <p><strong>Tipo:</strong> {booking.type.charAt(0).toUpperCase() + booking.type.slice(1)}</p>
          <p><strong>Nome:</strong> {booking.details.name || booking.details.title}</p>
          {booking.details.date && (
            <p><strong>Data:</strong> {new Date(booking.details.date).toLocaleDateString()}</p>
          )}
          {booking.details.location && (
            <p><strong>Luogo:</strong> {booking.details.location}</p>
          )}
          <div className="booking-price">
            <p><strong>Prezzo:</strong> {booking.details.price}€</p>
            <p><strong>Commissione servizio:</strong> {commission}€</p>
            <p className="total-price"><strong>Totale:</strong> {calculateTotal()}€</p>
          </div>
        </div>
        
        <form onSubmit={handleSubmit} className="payment-form">
          <div className="form-group">
            <label htmlFor="name">Nome completo</label>
            <input type="text" id="name" required />
          </div>
          
          <div className="form-group">
            <label htmlFor="email">Email</label>
            <input type="email" id="email" required />
          </div>
          
          <div className="form-group">
            <label>Carta di credito</label>
            <div className="card-element-container">
              <CardElement 
                options={{
                  style: {
                    base: {
                      fontSize: '16px',
                      color: '#424770',
                      '::placeholder': {
                        color: '#aab7c4',
                      },
                    },
                    invalid: {
                      color: '#9e2146',
                    },
                  },
                }}
              />
            </div>
          </div>
          
          {error && (
            <div className="error-message">{error}</div>
          )}
          
          <div className="payment-actions">
            <button type="button" className="cancel-button" onClick={onClose}>Annulla</button>
            <button 
              type="submit" 
              className="pay-button" 
              disabled={loading || !stripe}
            >
              {loading ? 'Elaborazione...' : `Paga ${calculateTotal()}€`}
            </button>
          </div>
          
          <div className="secure-payment-info">
            <svg className="lock-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24">
              <path d="M18 10v-4c0-3.313-2.687-6-6-6s-6 2.687-6 6v4h-3v14h18v-14h-3zm-5 7.723v2.277h-2v-2.277c-.595-.347-1-.984-1-1.723 0-1.104.896-2 2-2s2 .896 2 2c0 .738-.404 1.376-1 1.723zm-5-7.723v-4c0-2.206 1.794-4 4-4 2.205 0 4 1.794 4 4v4h-8z"/>
            </svg>
            <span>Pagamento sicuro con crittografia SSL</span>
          </div>
        </form>
      </div>
    </div>
  );
}

export default PaymentModal;

// PaymentService.js - Servizio per gestire i pagamenti
const PaymentService = {
  // Crea un intent di pagamento
  async createPaymentIntent(paymentDetails) {
    try {
      const response = await fetch('/api/payment/create-intent', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(paymentDetails),
      });
      
      if (!response.ok) {
        throw new Error('Errore nella creazione dell\'intent di pagamento');
      }
      
      return await response.json();
    } catch (error) {
      console.error('Errore nel servizio di pagamento:', error);
      throw error;
    }
  },
  
  // Verifica lo stato di un pagamento
  async checkPaymentStatus(paymentId) {
    try {
      const response = await fetch(`/api/payment/status/${paymentId}`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
        }
      });
      
      if (!response.ok) {
        throw new Error('Errore nella verifica dello stato del pagamento');
      }
      
      return await response.json();
    } catch (error) {
      console.error('Errore nella verifica dello stato del pagamento:', error);
      throw error;
    }
  }
};

export default PaymentService;

// ApiService.js - Aggiornato con la funzione di ricerca
const ApiService = {
  // Elabora la richiesta dell'utente tramite GPT
  async processUserRequest(message, userId) {
    try {
      const response = await fetch('/api/process', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ message, userId }),
      });
      
      if (!response.ok) {
        throw new Error('Errore nella comunicazione con il server');
      }
      
      return await response.json();
    } catch (error) {
      console.error('Errore nella comunicazione con l\'API:', error);
      throw error;
    }
  },
  
  // Cerca opzioni in base a criteri
  async searchOptions(query, type) {
    try {
      const response = await fetch(`/api/search?query=${encodeURIComponent(query)}&type=${encodeURIComponent(type)}`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
        }
      });
      
      if (!response.ok) {
        throw new Error('Errore nella ricerca');
      }
      
      return await response.json();
    } catch (error) {
      console.error('Errore nella ricerca:', error);
      throw error;
    }
  },
  
  // API per la prenotazione di hotel
  async bookHotel(bookingDetails) {
    // Integrazione con API reali di prenotazione hotel
    try {
      const response = await fetch('/api/book/hotel', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(bookingDetails),
      });
      
      return await response.json();
    } catch (error) {
      console.error('Errore nella prenotazione dell\'hotel:', error);
      throw error;
    }
  },
  
  // API per la prenotazione di ristoranti
  async bookRestaurant(bookingDetails) {
    // Integrazione con API reali di prenotazione ristoranti
    try {
      const response = await fetch('/api/book/restaurant', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(bookingDetails),
      });
      
      return await response.json();
    } catch (error) {
      console.error('Errore nella prenotazione del ristorante:', error);
      throw error;
    }
  },
  
  // Altre API di prenotazione simili...
};

export default ApiService;

// BookingService.js - Servizio per gestire le prenotazioni
const BookingService = {
  // Ottieni lo storico delle prenotazioni di un utente
  async getUserBookings(userId) {
    try {
      const response = await fetch(`/api/bookings/${userId}`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
        }
      });
      
      if (!response.ok) {
        throw new Error('Errore nel recupero delle prenotazioni');
      }
      
      return await response.json();
    } catch (error) {
      console.error('Errore nel recupero delle prenotazioni:', error);
      throw error;
    }
  },
  
  // Finalizza la prenotazione dopo il pagamento
  async finalizeBooking(booking, userId, paymentId) {
    try {
      const response = await fetch('/api/booking/finalize', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ 
          booking,
          userId,
          paymentId,
          commission: 0.50
        }),
      });
      
      if (!response.ok) {
        throw new Error('Errore nella finalizzazione della prenotazione');
      }
      
      return await response.json();
    } catch (error) {
      console.error('Errore nella finalizzazione della prenotazione:', error);
      throw error;
    }
  }
};

export default BookingService;

// Backend per gestire pagamenti e prenotazioni
// payment-routes.js
const express = require('express');
const router = express.Router();
const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);
const { Commission } = require('../models/commission');
const { Booking } = require('../models/booking');
const { User } = require('../models/user');

// Crea un intent di pagamento
router.post('/create-intent', async (req, res) => {
  try {
    const { amount, description, bookingType } = req.body;
    
    // Converti in centesimi per Stripe
    const amountInCents = Math.round(parseFloat(amount) * 100);
    
    const paymentIntent = await stripe.paymentIntents.create({
      amount: amountInCents,
      currency: 'eur',
      description,
      metadata: {
        bookingType,
        commission: '0.50'
      }
    });
    
    res.json({
      clientSecret: paymentIntent.client_secret,
      id: paymentIntent.id
    });
  } catch (error) {
    console.error('Errore nella creazione dell\'intent di pagamento:', error);
    res.status(500).json({ error: 'Errore nella creazione dell\'intent di pagamento' });
  }
});

// Verifica lo stato di un pagamento
router.get('/status/:paymentId', async (req, res) => {
  try {
    const { paymentId } = req.params;
    
    const paymentIntent = await stripe.paymentIntents.retrieve(paymentId);
    
    res.json({
      status: paymentIntent.status,
      succeeded: paymentIntent.status === 'succeeded'
    });
  } catch (error) {
    console.error('Errore nella verifica dello stato del pagamento:', error);
    res.status(500).json({ error: 'Errore nella verifica dello stato del pagamento' });
  }
});

// Gestisce il webhook di Stripe
router.post('/webhook', async (req, res) => {
  const sig = req.headers['stripe-signature'];
  const endpointSecret = process.env.STRIPE_WEBHOOK_SECRET;
  
  let event;
  
  try {
    event = stripe.webhooks.constructEvent(req.body, sig, endpointSecret);
  } catch (err) {
    console.error('Errore nella verifica della firma webhook:', err);
    return res.status(400).send(`Webhook Error: ${err.message}`);
  }
  
  // Gestisce eventi di pagamento completato
  if (event.type === 'payment_intent.succeeded') {
    const paymentIntent = event.data.object;
    
    // Registra la commissione
    try {
      const commission = new Commission({
        paymentId: paymentIntent.id,
        amount: 0.50,
        bookingType: paymentIntent.metadata.bookingType,
        createdAt: new Date()
      });
      
      await commission.save();
      console.log('Commissione registrata:', commission);
    } catch (error) {
      console.error('Errore nella registrazione della commissione:', error);
    }
  }
  
  res.json({ received: true });
});

module.exports = router;

// booking-routes.js
const express = require('express');
const router = express.Router();
const { Booking } = require('../models/booking');
const hotelAPI = require('../services/hotel-api');
const restaurantAPI = require('../services/restaurant-api');
const flightAPI = require('../services/flight-api');
const transportAPI = require('../services/transport-api');

// Finalizza la prenotazione dopo il pagamento
router.post('/finalize', async (req, res) => {
  try {
    const { booking, userId, paymentId, commission } = req.body;
    
    // Invia la prenotazione al servizio esterno appropriato
    let externalBookingResult;
    switch (booking.type) {
      case 'hotel':
        externalBookingResult = await hotelAPI.makeBooking(booking.details);
        break;
      case 'restaurant':
        externalBookingResult = await restaurantAPI.makeBooking(booking.details);
        break;
      case 'flight':
        externalBookingResult = await flightAPI.makeBooking(booking.details);
        break;
      case 'transport':
        externalBookingResult = await transportAPI.makeBooking(booking.details);
        break;
      default:
        throw new Error('Tipo di prenotazione non supportato');
    }
    
    // Registra la prenotazione nel database
    const newBooking = new Booking({
      userId,
      paymentId,
      type: booking.type,
      details: booking.details,
      externalReference: externalBookingResult.reference,
      status: 'confirmed',
      commission,
      totalPrice: parseFloat(booking.details.price) + parseFloat(commission),
      createdAt: new Date()
    });
    
    await newBooking.save();
    
    res.json({
      success: true,
      confirmationCode: externalBookingResult.reference,
      totalPrice: newBooking.totalPrice
    });
  } catch (error) {
    console.error('Errore nella finalizzazione della prenotazione:', error);
    res.status(500).json({ 
      error: 'Errore nella finalizzazione della prenotazione', 
      message: error.message 
    });
  }
});

// Ottieni lo storico delle prenotazioni di un utente
router.get('/:userId', async (req, res) => {
  try {
    const { userId } = req.params;
    const bookings = await Booking.find({ userId }).sort({ createdAt: -1
